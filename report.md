# Особенности тестирования

Тестирование проводилось на `Linux`.  
Используются одинаковые шаблоны для всех алгоритмов нахождения строк.  
При этом, генерируется много шаблонов для большей точности измерений.  
Каждый алгоритм поиска строк тестируется несколько раз, на одних и тех же входных данных.  
Затем, результаты измерений усредняются.  
Число генерируемых шаблонов контролируется параметром `-pr=<pattern_repeat_count>`, перезапусков алгоритма на одних и тех же входных данных - параметром `-tr=<test_repeat_count>`.  
По умолчанию, `-pr=100` и `-tr=100`. Тестирование проводилось на этих параметрах.  

# Результаты тестирования

## Измерение времени

Можно заметить, что алфавит (`DNA` или `Binary`), а в частности его размер (4 против 2), не влияет на время работы алгоритмов значительным образом. Графики по времени с разными алфавитами совпадают, но при прочих равных параметрах, почти совпадают (по разности скоростей алгоритмов).
На обоих графиках (без символов подстановки, 10000 символов) видно, что хоть наивный алгоритм и начинает с намного большего времени уже при длине паттерна 100, в итоге, проигрывает при длине паттерна в 3000 символов КМП (Стандартные грани), при этом выигрывая у КМП (Уточненные грани). Это связано с тем, что КМП алгоритмы производят дополнительный анализ паттерна, подсчитывая префикс-функцию, и накладные расходы на подсчет префикс-функцию слишком большие на маленьких паттернах, но при этом оправдывают себя на больших паттернах. КМП (Уточненные грани) проигрывает остальным алгоритмам из-за того, что помимо префикс-функции считает еще и массив уточненных граней.  
Также КМП-алгоритмы со стандартными и уточненными гранями используют доп. память, равную `O(pattern.size())` и `O(2*pattern.size()) = O(2*pattern.size())` соответственно. Так как доп. память реализуется на векторах, возникают доп. временные расходы на работу с векторами немалых размеров. В сравнении, наивный алгоритм не использует доп. память (т. е. доп. память равна `O(1)`), что позволяет ему слегка выиграть по времени в этом контексте.  
При этом, время работы алгоритмов оцениваются как `O(text.size() * pattern.size())`, `O(text.size() + pattern.size())`, `O(text.size() + 2*pattern.size()) = O(text.size() + pattern.size())` для наивного, КМП (Стандартные грани) и КМП (Уточненные грани) алгоритмов соответственно. Значит, по графикам можно заключить, что на практике, несмотря на асимптотическую оптимальность КМП-алгоритмов, из-за накладных расходов, которые спрятаны в скрытой константе в `O(...)`, наивный алгоритм может оказаться более эффективным, особенно на данных с малым размером паттерна.  
  
Стоит отметить, что КМП-алгоритмы оказались значительно хуже для строк с символами подстановки по сравнению с наивным алгоритмом. Это связано c реализацией КМП-алгоритмов для поиска строк с символами подстановки, которая основана на КМП-алгоритмах поиска без символов подстановки. В предложенной реализации, для каждой подстроки из паттерна без символов подстановок, ограниченной символами подстановок (см. https://neerc.ifmo.ru/wiki/index.php?title=%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%90%D1%85%D0%BE-%D0%9A%D0%BE%D1%80%D0%B0%D1%81%D0%B8%D0%BA : Поиск шаблонов с масками), выполняется поиск данной подстроки в тексте, что уже примерно увеличивает скорость работы в `wildcard_count + 1` раз. Также используется доп. память на векторах, равная (примерно) `O(text.size() + pattern.size() - wildcard_count)`, что также увеличивает скорость работы. Временные асимптотики (в среднем): `O(text.size() * pattern.size())`, `O((wildcard_count + 1) * (text.size() + pattern.size()))`, `O((wildcard_count + 1) * (text.size() + pattern.size()))` для наивного, КМП (Стандартные грани) и КМП (Уточненные грани) алгоритмов соответственно.  
  
КМП-алгоритмы оказались быстрее наивного алгоритма при большой длине текста в 100000 символов, без символов подстановки. При этом, на обоих графиках, КМП (Уточненные грани) слегка выигрывает у КМП (Стандартные грани). Это связано с более качественном анализе паттерна, длина которого намного меньше, чем длина текста, что позволяет асимптотически выиграть.

Также, можно отметить, что время работы наивного алгоритма почти не меняется на графиках с символами подстановки. Это объясняется тем, что из-за простоты алгоритма наличие символов подстановки не влияет на его скорость работы при разных длинах паттерна (по сути, используется тот же наивный алгоритм без символов подстановки), в отличие от КМП-алгоритмов, для которых предварительный анализ паттерна сильно зависит от количества и расположения символов подстановки, которые определяются случайно.  

## Измерение количества сравнений символов

Почти во всех графиках КМП-алгоритмам нужно произвести значительно больше сравнений символов из-за предварительного анализа паттерна, реализации поиска с символами подстановки. При этом линия наивного алгоритма растет почти линейно, что соответствует ожидаемому поведению - при увеличении `pattern_length` на `k`, внутренний цикл `for` повторится `pattern_length + k` раз.  
  
Для КМП-алгоритмов свойственны резкие скачки/падения на графиках - их алгоритмы зависят от удачности паттерна, как с символами подстановки, так и без. На графиках с символами подстановки КМП-алгоритмы демонстрируют почти одинаковые результаты для 4-символьного `DNA` текста, различия чуть более выражены в 2-символьном `Binary` тексте - их алгоритмы почти те же, КМП (Уточненные грани) оказался более эффективен на алфавите меньшего размера.  
  
Только на одном графике (без символов подстановки, 100000 символов, Binary) КМП (Уточненные грани) показывает эффективность в посимвольном сравнении. Это связано с предварительным анализом паттерна, время исполнения которого не играют большой роли на тексте такого большого размера, позволяя после подсчета префикс-функции производить намного меньше сравнений за счет пропуска некоторых состояний.  
  
Также стоит заметить, что линиям КМП-алгоритмов на графиках без символов подстановки не свойственны существенные скачки - символы подстановки вставляются в случайные места паттерна, что делает анализ паттерна более непредсказуемым, и позволяет выиграть/проиграть время за счет удачливости паттерна.   

# Выводы

КМП-алгоритмы становятся эффективными на текстах большого размера, по сравнению с наивным алгоритмом.  
Однако, с символами подстановки, количество и расположении которых случайно, КМП-алгоритмы начинают вести себя нестабильно и могут стать неэффективными за счет удачливости паттерна и необходимости анализа данного паттерна.  
Наивный алгоритм не испытывает резких скачков на графиках за счет независимости от удачливости паттерна и даже иногда выигрывает у КМП-алгоритмов, благодаря отсутствию накладных расходов на доп. память.  
На текстах большого размера КМП (Уточненные грани) оказывается более эффективным, чем КМП (Стандартные грани), благодаря более качественному анализу паттерна.  
